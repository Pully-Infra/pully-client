{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import {\n  IListen,\n  IMessage,\n  Primitives,\n  IListenReturn,\n  IConnectionInfo,\n  IPullyClassInstance,\n} from \"./interfaces/types\";\nimport { io, Socket } from \"socket.io-client\";\n\nconst PULLY_EVENTS = {\n  SUBSCRIBE: \"subscribe\",\n  RECEIVE_MESSAGE: \"message\",\n  UNSUBSCRIBE: \"unsubscribe\",\n  SEND_MESSAGE: \"send_message\",\n};\n\nclass Pully {\n  private serverUrl: string;\n  private socketInstance: Socket | null = null;\n\n  protected channels: string[] = [];\n  protected pullyClassInstance = {} as IPullyClassInstance;\n\n  constructor(connectionInfo: IConnectionInfo) {\n    this.serverUrl = connectionInfo.serverUrl;\n\n    if (!this.socketInstance) {\n      const token = connectionInfo.token;\n      const autoConnect = connectionInfo.autoConnect;\n\n      const connected = autoConnect !== undefined ? autoConnect : true;\n\n      this.socketInstance = io(this.serverUrl, {\n        // autoConnect: connected,\n        extraHeaders: {\n          token,\n        },\n      });\n    }\n\n    this.pullyClassInstance.listen = () => null;\n    this.pullyClassInstance.sendMessage = () => null;\n    this.pullyClassInstance.unsubscribe = () => null;\n  }\n\n  /**\n   * Subscribe to a channel\n   * @param {string} channelName (required) - The name of the channel to subscribe to.\n   * */\n\n  public subscribe(channelName: string) {\n    // this._checkConnection();\n\n    this.socketInstance?.emit(PULLY_EVENTS.SUBSCRIBE, channelName);\n    this.channels.push(channelName);\n\n    const listen = this._listen();\n    const sendMessage = this._sendMessage(channelName);\n    const unsubscribe = () => this.unsubscribe(channelName);\n\n    this.pullyClassInstance.listen = listen;\n    this.pullyClassInstance.sendMessage = sendMessage;\n    this.pullyClassInstance.unsubscribe = unsubscribe;\n\n    return this.pullyClassInstance;\n  }\n\n  /**\n   * Un-Subscribe from a channel\n   * @param {string} channelName (required) - The name of the channel to unsubscribe from.\n   * */\n\n  public unsubscribe(channelName: string) {\n    // this._checkConnection();\n\n    this.socketInstance?.emit(PULLY_EVENTS.UNSUBSCRIBE, channelName);\n    const channelIndex = this.channels.findIndex(\n      (channel) => channel === channelName\n    );\n    const channels = [...this.channels];\n    channels.splice(channelIndex, 1);\n    this.channels = channels;\n  }\n\n  /**\n   * Check if a channel exists\n   * @param {string} channelName (required) - The name of the channel to check\n   * */\n\n  public channelExists(channelName: string) {\n    if (this.channels.includes(channelName)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Retrieve all channels\n   * */\n\n  public getChannels() {\n    return this.channels;\n  }\n\n  /**\n   * Connect to socket instance. You need to call this if autoConnect is set to false\n   * */\n\n  public connect() {\n    this.socketInstance?.connect();\n  }\n\n  /**\n   * Send Message to a channel\n   * @param {string} channelName: (required) - The name of the channel you want to send a message to\n   * @returns (message: M) => void\n   * */\n\n  public sendMessage<M extends Primitives>(\n    channelName: string,\n    data: IMessage<M>\n  ) {\n    // this._checkConnection();\n\n    const sendMessage = this._sendMessage(channelName);\n    return sendMessage(data);\n  }\n\n  /**\n   * Listen to a custom event\n   * @param {string} eventName (required) - The name of the channel to listen to.\n   * */\n\n  public listen({ eventName, callback }: IListen) {\n    const listen = this._listen();\n    listen({ eventName, callback });\n  }\n\n  protected _listen() {\n    return ({\n      eventName = PULLY_EVENTS.RECEIVE_MESSAGE,\n      callback,\n    }: IListen) => {\n      this.socketInstance?.on(eventName, (data: IListenReturn) => {\n        callback(data);\n      });\n    };\n  }\n\n  protected _sendMessage<M extends Primitives>(channelName: string) {\n    return (data: IMessage<M>) => {\n      const { event, message, timeout = 0 } = data;\n\n      const messageToSend = {\n        channelName,\n        message,\n        event,\n      };\n\n      if (timeout > 0) {\n        this.socketInstance\n          ?.timeout(timeout)\n          .emit(PULLY_EVENTS.SEND_MESSAGE, messageToSend);\n      } else {\n        this.socketInstance?.emit(PULLY_EVENTS.SEND_MESSAGE, messageToSend);\n      }\n    };\n  }\n\n  protected _checkConnection = () => {\n    if (!this.socketInstance?.connected) {\n      throw new Error(\n        \"You need to Connect to the Socket Instance. Call the connect method to instantiate a connection\"\n      );\n    }\n  };\n}\n\nexport default Pully;\n"],"mappings":"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","names":[]}